\doxysection{node\+\_\+modules/router Directory Reference}
\hypertarget{dir_4268efdb8052a061d67e77646306f2cb}{}\label{dir_4268efdb8052a061d67e77646306f2cb}\index{node\_modules/router Directory Reference@{node\_modules/router Directory Reference}}
\doxysubsubsection*{Directories}
\begin{DoxyCompactItemize}
\item 
directory \mbox{\hyperlink{dir_a215fe11fe30575b56014d24314a8286}{lib}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\href{https://npmjs.org/package/router}{\texttt{ }} \href{https://npmjs.org/package/router}{\texttt{ }} \href{http://nodejs.org/download/}{\texttt{ }} \href{https://github.com/pillarjs/router/actions/workflows/ci.yml}{\texttt{ }} \href{https://coveralls.io/r/pillarjs/router?branch=master}{\texttt{ }}

Simple middleware-\/style router\hypertarget{README.md_autotoc_md3470}{}\doxysubsection{\texorpdfstring{Installation}{Installation}}\label{README.md_autotoc_md3470}
This is a \href{https://nodejs.org/en/}{\texttt{ Node.\+js}} module available through the \href{https://www.npmjs.com/}{\texttt{ npm registry}}. Installation is done using the \href{https://docs.npmjs.com/getting-started/installing-npm-packages-locally}{\texttt{ {\ttfamily npm install} command}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$\ npm\ install\ router}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3471}{}\doxysubsection{\texorpdfstring{API}{API}}\label{README.md_autotoc_md3471}

\begin{DoxyCode}{0}
\DoxyCodeLine{var\ finalhandler\ =\ require('finalhandler')}
\DoxyCodeLine{var\ http\ =\ require('http')}
\DoxyCodeLine{var\ Router\ =\ require('router')}
\DoxyCodeLine{}
\DoxyCodeLine{var\ router\ =\ Router()}
\DoxyCodeLine{router.get('/',\ function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ res.setHeader('Content-\/Type',\ 'text/plain;\ charset=utf-\/8')}
\DoxyCodeLine{\ \ res.end('Hello\ World!')}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{var\ server\ =\ http.createServer(function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ router(req,\ res,\ finalhandler(req,\ res))}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{server.listen(3000)}

\end{DoxyCode}


This module is currently an extracted version from the Express project, but with the main change being it can be used with a plain {\ttfamily http.\+create\+Server} object or other web frameworks by removing Express-\/specific API calls.\hypertarget{README.md_autotoc_md3472}{}\doxysubsection{\texorpdfstring{Router(options)}{Router(options)}}\label{README.md_autotoc_md3472}
Options


\begin{DoxyItemize}
\item {\ttfamily strict} -\/ When {\ttfamily false} trailing slashes are optional (default\+: {\ttfamily false})
\item {\ttfamily case\+Sensitive} -\/ When {\ttfamily true} the routing will be case sensitive. (default\+: {\ttfamily false})
\item {\ttfamily merge\+Params} -\/ When {\ttfamily true} any {\ttfamily req.\+params} passed to the router will be merged into the router\textquotesingle{}s {\ttfamily req.\+params}. (default\+: {\ttfamily false}) (example)
\end{DoxyItemize}

Returns a function with the signature {\ttfamily router(req, res, callback)} where {\ttfamily callback(\mbox{[}err\mbox{]})} must be provided to handle errors and fall-\/through from not handling requests.\hypertarget{README.md_autotoc_md3473}{}\doxysubsubsection{\texorpdfstring{router.\+use(\mbox{[}path\mbox{]}, ...\+middleware)}{router.\+use(\mbox{[}path\mbox{]}, ...\+middleware)}}\label{README.md_autotoc_md3473}
Use the given middleware function for all http methods on the given {\ttfamily path}, defaulting to the root path.

{\ttfamily router} does not automatically see {\ttfamily use} as a handler. As such, it will not consider it one for handling {\ttfamily OPTIONS} requests.


\begin{DoxyItemize}
\item Note\+: If a {\ttfamily path} is specified, that {\ttfamily path} is stripped from the start of {\ttfamily req.\+url}.
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{router.use(function\ (req,\ res,\ next)\ \{}
\DoxyCodeLine{\ \ //\ do\ your\ things}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ continue\ to\ the\ next\ middleware}
\DoxyCodeLine{\ \ //\ the\ request\ will\ stall\ if\ this\ is\ not\ called}
\DoxyCodeLine{\ \ next()}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ note:\ you\ should\ NOT\ call\ \`{}next`\ if\ you\ have\ begun\ writing\ to\ the\ response}
\DoxyCodeLine{\})}

\end{DoxyCode}


Middleware can themselves use `next(\textquotesingle{}router')\`{} at any time to exit the current router instance completely, invoking the top-\/level callback.\hypertarget{README.md_autotoc_md3474}{}\doxysubsubsection{\texorpdfstring{router\mbox{[}method\mbox{]}(path, ...\mbox{[}middleware\mbox{]}, handler)}{router\mbox{[}method\mbox{]}(path, ...\mbox{[}middleware\mbox{]}, handler)}}\label{README.md_autotoc_md3474}
The \href{https://github.com/jshttp/methods/blob/master/index.js}{\texttt{ http methods}} provide the routing functionality in {\ttfamily router}.

Method middleware and handlers follow usual middleware behavior, except they will only be called when the method and path match the request.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ handle\ a\ \`{}GET`\ request}
\DoxyCodeLine{router.get('/',\ function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ res.setHeader('Content-\/Type',\ 'text/plain;\ charset=utf-\/8')}
\DoxyCodeLine{\ \ res.end('Hello\ World!')}
\DoxyCodeLine{\})}

\end{DoxyCode}


Middleware given before the handler have one additional trick, they may invoke `next(\textquotesingle{}route'){\ttfamily . Calling}next(\textquotesingle{}route\textquotesingle{})\`{} bypasses the remaining middleware and the handler mounted for this route, passing the request to the next route suitable for handling this request.

Route handlers and middleware can themselves use `next(\textquotesingle{}router')\`{} at any time to exit the current router instance completely, invoking the top-\/level callback.\hypertarget{README.md_autotoc_md3475}{}\doxysubsubsection{\texorpdfstring{router.\+param(name, param\+\_\+middleware)}{router.\+param(name, param\+\_\+middleware)}}\label{README.md_autotoc_md3475}
Maps the specified path parameter {\ttfamily name} to a specialized param-\/capturing middleware.

This function positions the middleware in the same stack as {\ttfamily .use}.

The function can optionally return a {\ttfamily Promise} object. If a {\ttfamily Promise} object is returned from the function, the router will attach an {\ttfamily on\+Rejected} callback using {\ttfamily .then}. If the promise is rejected, {\ttfamily next} will be called with the rejected value, or an error if the value is falsy.

Parameter mapping is used to provide pre-\/conditions to routes which use normalized placeholders. For example a {\itshape \+:user\+\_\+id} parameter could automatically load a user\textquotesingle{}s information from the database without any additional code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{router.param('user\_id',\ function\ (req,\ res,\ next,\ id)\ \{}
\DoxyCodeLine{\ \ User.find(id,\ function\ (err,\ user)\ \{}
\DoxyCodeLine{\ \ \ \ if\ (err)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ return\ next(err)}
\DoxyCodeLine{\ \ \ \ \}\ else\ if\ (!user)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ return\ next(new\ Error('failed\ to\ load\ user'))}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ req.user\ =\ user}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ continue\ processing\ the\ request}
\DoxyCodeLine{\ \ \ \ next()}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3476}{}\doxysubsubsection{\texorpdfstring{router.\+route(path)}{router.\+route(path)}}\label{README.md_autotoc_md3476}
Creates an instance of a single {\ttfamily Route} for the given {\ttfamily path}. (See {\ttfamily Router.\+Route} below)

Routes can be used to handle http {\ttfamily methods} with their own, optional middleware.

Using {\ttfamily router.\+route(path)} is a recommended approach to avoiding duplicate route naming and thus typo errors.


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ api\ =\ router.route('/api/')}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3477}{}\doxysubsection{\texorpdfstring{Router.\+Route(path)}{Router.\+Route(path)}}\label{README.md_autotoc_md3477}
Represents a single route as an instance that can be used to handle http {\ttfamily methods} with it\textquotesingle{}s own, optional middleware.\hypertarget{README.md_autotoc_md3478}{}\doxysubsubsection{\texorpdfstring{route\mbox{[}method\mbox{]}(handler)}{route\mbox{[}method\mbox{]}(handler)}}\label{README.md_autotoc_md3478}
These are functions which you can directly call on a route to register a new {\ttfamily handler} for the {\ttfamily method} on the route.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ handle\ a\ \`{}GET`\ request}
\DoxyCodeLine{var\ status\ =\ router.route('/status')}
\DoxyCodeLine{}
\DoxyCodeLine{status.get(function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ res.setHeader('Content-\/Type',\ 'text/plain;\ charset=utf-\/8')}
\DoxyCodeLine{\ \ res.end('All\ Systems\ Green!')}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3479}{}\doxysubsubsection{\texorpdfstring{route.\+all(handler)}{route.\+all(handler)}}\label{README.md_autotoc_md3479}
Adds a handler for all HTTP methods to this route.

The handler can behave like middleware and call {\ttfamily next} to continue processing rather than responding.


\begin{DoxyCode}{0}
\DoxyCodeLine{router.route('/')}
\DoxyCodeLine{\ \ .all(function\ (req,\ res,\ next)\ \{}
\DoxyCodeLine{\ \ \ \ next()}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .all(checkSomething)}
\DoxyCodeLine{\ \ .get(function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ \ \ res.setHeader('Content-\/Type',\ 'text/plain;\ charset=utf-\/8')}
\DoxyCodeLine{\ \ \ \ res.end('Hello\ World!')}
\DoxyCodeLine{\ \ \})}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3480}{}\doxysubsection{\texorpdfstring{Middleware}{Middleware}}\label{README.md_autotoc_md3480}
Middleware (and method handlers) are functions that follow specific function parameters and have defined behavior when used with {\ttfamily router}. The most common format is with three parameters -\/ "{}req"{}, "{}res"{} and "{}next"{}.


\begin{DoxyItemize}
\item {\ttfamily req} -\/ This is a \href{https://nodejs.org/api/http.html\#http_http_incomingmessage}{\texttt{ HTTP incoming message}} instance.
\item {\ttfamily res} -\/ This is a \href{https://nodejs.org/api/http.html\#http_class_http_serverresponse}{\texttt{ HTTP server response}} instance.
\item {\ttfamily next} -\/ Calling this function that tells {\ttfamily router} to proceed to the next matching middleware or method handler. It accepts an error as the first argument.
\end{DoxyItemize}

The function can optionally return a {\ttfamily Promise} object. If a {\ttfamily Promise} object is returned from the function, the router will attach an {\ttfamily on\+Rejected} callback using {\ttfamily .then}. If the promise is rejected, {\ttfamily next} will be called with the rejected value, or an error if the value is falsy.

Middleware and method handlers can also be defined with four arguments. When the function has four parameters defined, the first argument is an error and subsequent arguments remain, becoming -\/ "{}err"{}, "{}req"{}, "{}res"{}, "{}next"{}. These functions are "{}error handling middleware"{}, and can be used for handling errors that occurred in previous handlers (E.\+g. from calling {\ttfamily next(err)}). This is most used when you want to define arbitrary rendering of errors.


\begin{DoxyCode}{0}
\DoxyCodeLine{router.get('/error\_route',\ function\ (req,\ res,\ next)\ \{}
\DoxyCodeLine{\ \ return\ next(new\ Error('Bad\ Request'))}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{router.use(function\ (err,\ req,\ res,\ next)\ \{}
\DoxyCodeLine{\ \ res.end(err.message)\ //=\ >\ "{}Bad\ Request"{}}
\DoxyCodeLine{\})}

\end{DoxyCode}


Error handling middleware will {\bfseries{only}} be invoked when an error was given. As long as the error is in the pipeline, normal middleware and handlers will be bypassed -\/ only error handling middleware will be invoked with an error.\hypertarget{README.md_autotoc_md3481}{}\doxysubsection{\texorpdfstring{Examples}{Examples}}\label{README.md_autotoc_md3481}

\begin{DoxyCode}{0}
\DoxyCodeLine{//\ import\ our\ modules}
\DoxyCodeLine{var\ http\ =\ require('http')}
\DoxyCodeLine{var\ Router\ =\ require('router')}
\DoxyCodeLine{var\ finalhandler\ =\ require('finalhandler')}
\DoxyCodeLine{var\ compression\ =\ require('compression')}
\DoxyCodeLine{var\ bodyParser\ =\ require('body-\/parser')}
\DoxyCodeLine{}
\DoxyCodeLine{//\ store\ our\ message\ to\ display}
\DoxyCodeLine{var\ message\ =\ 'Hello\ World!'}
\DoxyCodeLine{}
\DoxyCodeLine{//\ initialize\ the\ router\ \&\ server\ and\ add\ a\ final\ callback.}
\DoxyCodeLine{var\ router\ =\ Router()}
\DoxyCodeLine{var\ server\ =\ http.createServer(function\ onRequest\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ router(req,\ res,\ finalhandler(req,\ res))}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ use\ some\ middleware\ and\ compress\ all\ outgoing\ responses}
\DoxyCodeLine{router.use(compression())}
\DoxyCodeLine{}
\DoxyCodeLine{//\ handle\ \`{}GET`\ requests\ to\ \`{}/message`}
\DoxyCodeLine{router.get('/message',\ function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ res.statusCode\ =\ 200}
\DoxyCodeLine{\ \ res.setHeader('Content-\/Type',\ 'text/plain;\ charset=utf-\/8')}
\DoxyCodeLine{\ \ res.end(message\ +\ '\(\backslash\)n')}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ create\ and\ mount\ a\ new\ router\ for\ our\ API}
\DoxyCodeLine{var\ api\ =\ Router()}
\DoxyCodeLine{router.use('/api/',\ api)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ add\ a\ body\ parsing\ middleware\ to\ our\ API}
\DoxyCodeLine{api.use(bodyParser.json())}
\DoxyCodeLine{}
\DoxyCodeLine{//\ handle\ \`{}PATCH`\ requests\ to\ \`{}/api/set-\/message`}
\DoxyCodeLine{api.patch('/set-\/message',\ function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ if\ (req.body.value)\ \{}
\DoxyCodeLine{\ \ \ \ message\ =\ req.body.value}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ res.statusCode\ =\ 200}
\DoxyCodeLine{\ \ \ \ res.setHeader('Content-\/Type',\ 'text/plain;\ charset=utf-\/8')}
\DoxyCodeLine{\ \ \ \ res.end(message\ +\ '\(\backslash\)n')}
\DoxyCodeLine{\ \ \}\ else\ \{}
\DoxyCodeLine{\ \ \ \ res.statusCode\ =\ 400}
\DoxyCodeLine{\ \ \ \ res.setHeader('Content-\/Type',\ 'text/plain;\ charset=utf-\/8')}
\DoxyCodeLine{\ \ \ \ res.end('Invalid\ API\ Syntax\(\backslash\)n')}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ make\ our\ http\ server\ listen\ to\ connections}
\DoxyCodeLine{server.listen(8080)}

\end{DoxyCode}


You can get the message by running this command in your terminal, or navigating to {\ttfamily 127.\+0.\+0.\+1\+:8080} in a web browser. 
\begin{DoxyCode}{0}
\DoxyCodeLine{curl\ http://127.0.0.1:8080}

\end{DoxyCode}


You can set the message by sending it a {\ttfamily PATCH} request via this command\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{curl\ http://127.0.0.1:8080/api/set-\/message\ -\/X\ PATCH\ -\/H\ "{}Content-\/Type:\ application/json"{}\ -\/d\ '\{"{}value"{}:"{}Cats!"{}\}'}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3482}{}\doxysubsubsection{\texorpdfstring{Example using merge\+Params}{Example using merge\+Params}}\label{README.md_autotoc_md3482}

\begin{DoxyCode}{0}
\DoxyCodeLine{var\ http\ =\ require('http')}
\DoxyCodeLine{var\ Router\ =\ require('router')}
\DoxyCodeLine{var\ finalhandler\ =\ require('finalhandler')}
\DoxyCodeLine{}
\DoxyCodeLine{//\ this\ example\ is\ about\ the\ mergeParams\ option}
\DoxyCodeLine{var\ opts\ =\ \{\ mergeParams:\ true\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ make\ a\ router\ with\ out\ special\ options}
\DoxyCodeLine{var\ router\ =\ Router(opts)}
\DoxyCodeLine{var\ server\ =\ http.createServer(function\ onRequest\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ //\ set\ something\ to\ be\ passed\ into\ the\ router}
\DoxyCodeLine{\ \ req.params\ =\ \{\ type:\ 'kitten'\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ router(req,\ res,\ finalhandler(req,\ res))}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{router.get('/',\ function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ res.statusCode\ =\ 200}
\DoxyCodeLine{\ \ res.setHeader('Content-\/Type',\ 'text/plain;\ charset=utf-\/8')}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ with\ respond\ with\ the\ the\ params\ that\ were\ passed\ in}
\DoxyCodeLine{\ \ res.end(req.params.type\ +\ '\(\backslash\)n')}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ make\ another\ router\ with\ our\ options}
\DoxyCodeLine{var\ handler\ =\ Router(opts)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ mount\ our\ new\ router\ to\ a\ route\ that\ accepts\ a\ param}
\DoxyCodeLine{router.use('/:path',\ handler)}
\DoxyCodeLine{}
\DoxyCodeLine{handler.get('/',\ function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ res.statusCode\ =\ 200}
\DoxyCodeLine{\ \ res.setHeader('Content-\/Type',\ 'text/plain;\ charset=utf-\/8')}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ will\ respond\ with\ the\ param\ of\ the\ router's\ parent\ route}
\DoxyCodeLine{\ \ res.end(req.params.path\ +\ '\(\backslash\)n')}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ make\ our\ http\ server\ listen\ to\ connections}
\DoxyCodeLine{server.listen(8080)}

\end{DoxyCode}


Now you can get the type, or what path you are requesting\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{curl\ http://127.0.0.1:8080}
\DoxyCodeLine{>\ kitten}
\DoxyCodeLine{curl\ http://127.0.0.1:8080/such\_path}
\DoxyCodeLine{>\ such\_path}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3483}{}\doxysubsubsection{\texorpdfstring{Example of advanced {\ttfamily .route()} usage}{Example of advanced {\ttfamily .route()} usage}}\label{README.md_autotoc_md3483}
This example shows how to implement routes where there is a custom handler to execute when the path matched, but no methods matched. Without any special handling, this would be treated as just a generic non-\/match by {\ttfamily router} (which typically results in a 404), but with a custom handler, a {\ttfamily 405 Method Not Allowed} can be sent.


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ http\ =\ require('http')}
\DoxyCodeLine{var\ finalhandler\ =\ require('finalhandler')}
\DoxyCodeLine{var\ Router\ =\ require('router')}
\DoxyCodeLine{}
\DoxyCodeLine{//\ create\ the\ router\ and\ server}
\DoxyCodeLine{var\ router\ =\ new\ Router()}
\DoxyCodeLine{var\ server\ =\ http.createServer(function\ onRequest\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ router(req,\ res,\ finalhandler(req,\ res))}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ register\ a\ route\ and\ add\ all\ methods}
\DoxyCodeLine{router.route('/pet/:id')}
\DoxyCodeLine{\ \ .get(function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ \ \ //\ this\ is\ GET\ /pet/:id}
\DoxyCodeLine{\ \ \ \ res.setHeader('Content-\/Type',\ 'application/json')}
\DoxyCodeLine{\ \ \ \ res.end(JSON.stringify(\{\ name:\ 'tobi'\ \}))}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .delete(function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ \ \ //\ this\ is\ DELETE\ /pet/:id}
\DoxyCodeLine{\ \ \ \ res.end()}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .all(function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ \ \ //\ this\ is\ called\ for\ all\ other\ methods\ not}
\DoxyCodeLine{\ \ \ \ //\ defined\ above\ for\ /pet/:id}
\DoxyCodeLine{\ \ \ \ res.statusCode\ =\ 405}
\DoxyCodeLine{\ \ \ \ res.end()}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ make\ our\ http\ server\ listen\ to\ connections}
\DoxyCodeLine{server.listen(8080)}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3484}{}\doxysubsection{\texorpdfstring{License}{License}}\label{README.md_autotoc_md3484}
\mbox{[}MIT\mbox{]}(LICENSE) 