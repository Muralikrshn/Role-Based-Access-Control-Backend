\doxysection{node\+\_\+modules/type-\/is Directory Reference}
\hypertarget{dir_88beac70c9a3d112588b30b859ce7733}{}\label{dir_88beac70c9a3d112588b30b859ce7733}\index{node\_modules/type-\/is Directory Reference@{node\_modules/type-\/is Directory Reference}}


\doxysubsection{Detailed Description}
\href{https://npmjs.org/package/type-is}{\texttt{ }} \href{https://npmjs.org/package/type-is}{\texttt{ }} \href{https://nodejs.org/en/download}{\texttt{ }} \href{https://github.com/jshttp/type-is/actions/workflows/ci.yml}{\texttt{ }} \href{https://coveralls.io/r/jshttp/type-is?branch=master}{\texttt{ }}

Infer the content-\/type of a request.\hypertarget{README.md_autotoc_md4016}{}\doxysubsection{\texorpdfstring{Install}{Install}}\label{README.md_autotoc_md4016}
This is a \href{https://nodejs.org/en/}{\texttt{ Node.\+js}} module available through the \href{https://www.npmjs.com/}{\texttt{ npm registry}}. Installation is done using the \href{https://docs.npmjs.com/getting-started/installing-npm-packages-locally}{\texttt{ {\ttfamily npm install} command}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$\ npm\ install\ type-\/is}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md4017}{}\doxysubsection{\texorpdfstring{API}{API}}\label{README.md_autotoc_md4017}

\begin{DoxyCode}{0}
\DoxyCodeLine{var\ http\ =\ require('http')}
\DoxyCodeLine{var\ typeis\ =\ require('type-\/is')}
\DoxyCodeLine{}
\DoxyCodeLine{http.createServer(function\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ var\ istext\ =\ typeis(req,\ ['text/*'])}
\DoxyCodeLine{\ \ res.end('you\ '\ +\ (istext\ ?\ 'sent'\ :\ 'did\ not\ send')\ +\ '\ me\ text')}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md4018}{}\doxysubsubsection{\texorpdfstring{typeis(request, types)}{typeis(request, types)}}\label{README.md_autotoc_md4018}
Checks if the {\ttfamily request} is one of the {\ttfamily types}. If the request has no body, even if there is a {\ttfamily Content-\/\+Type} header, then {\ttfamily null} is returned. If the {\ttfamily Content-\/\+Type} header is invalid or does not matches any of the {\ttfamily types}, then {\ttfamily false} is returned. Otherwise, a string of the type that matched is returned.

The {\ttfamily request} argument is expected to be a Node.\+js HTTP request. The {\ttfamily types} argument is an array of type strings.

Each type in the {\ttfamily types} array can be one of the following\+:


\begin{DoxyItemize}
\item A file extension name such as {\ttfamily json}. This name will be returned if matched.
\item A mime type such as {\ttfamily application/json}.
\item A mime type with a wildcard such as {\ttfamily \texorpdfstring{$\ast$}{*}/\texorpdfstring{$\ast$}{*}} or {\ttfamily \texorpdfstring{$\ast$}{*}/json} or {\ttfamily application/\texorpdfstring{$\ast$}{*}}. The full mime type will be returned if matched.
\item A suffix such as {\ttfamily +json}. This can be combined with a wildcard such as {\ttfamily \texorpdfstring{$\ast$}{*}/vnd+json} or {\ttfamily application/\texorpdfstring{$\ast$}{*}+json}. The full mime type will be returned if matched.
\end{DoxyItemize}

Some examples to illustrate the inputs and returned value\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ req.headers.content-\/type\ =\ 'application/json'}
\DoxyCodeLine{}
\DoxyCodeLine{typeis(req,\ ['json'])\ //\ =>\ 'json'}
\DoxyCodeLine{typeis(req,\ ['html',\ 'json'])\ //\ =>\ 'json'}
\DoxyCodeLine{typeis(req,\ ['application/*'])\ //\ =>\ 'application/json'}
\DoxyCodeLine{typeis(req,\ ['application/json'])\ //\ =>\ 'application/json'}
\DoxyCodeLine{}
\DoxyCodeLine{typeis(req,\ ['html'])\ //\ =>\ false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md4019}{}\doxysubsubsection{\texorpdfstring{typeis.\+has\+Body(request)}{typeis.\+has\+Body(request)}}\label{README.md_autotoc_md4019}
Returns a Boolean if the given {\ttfamily request} has a body, regardless of the {\ttfamily Content-\/\+Type} header.

Having a body has no relation to how large the body is (it may be 0 bytes). This is similar to how file existence works. If a body does exist, then this indicates that there is data to read from the Node.\+js request stream.


\begin{DoxyCode}{0}
\DoxyCodeLine{if\ (typeis.hasBody(req))\ \{}
\DoxyCodeLine{\ \ //\ read\ the\ body,\ since\ there\ is\ one}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ req.on('data',\ function\ (chunk)\ \{}
\DoxyCodeLine{\ \ \ \ //\ ...}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md4020}{}\doxysubsubsection{\texorpdfstring{typeis.\+is(media\+Type, types)}{typeis.\+is(media\+Type, types)}}\label{README.md_autotoc_md4020}
Checks if the {\ttfamily media\+Type} is one of the {\ttfamily types}. If the {\ttfamily media\+Type} is invalid or does not matches any of the {\ttfamily types}, then {\ttfamily false} is returned. Otherwise, a string of the type that matched is returned.

The {\ttfamily media\+Type} argument is expected to be a \href{https://tools.ietf.org/html/rfc6838}{\texttt{ media type}} string. The {\ttfamily types} argument is an array of type strings.

Each type in the {\ttfamily types} array can be one of the following\+:


\begin{DoxyItemize}
\item A file extension name such as {\ttfamily json}. This name will be returned if matched.
\item A mime type such as {\ttfamily application/json}.
\item A mime type with a wildcard such as {\ttfamily \texorpdfstring{$\ast$}{*}/\texorpdfstring{$\ast$}{*}} or {\ttfamily \texorpdfstring{$\ast$}{*}/json} or {\ttfamily application/\texorpdfstring{$\ast$}{*}}. The full mime type will be returned if matched.
\item A suffix such as {\ttfamily +json}. This can be combined with a wildcard such as {\ttfamily \texorpdfstring{$\ast$}{*}/vnd+json} or {\ttfamily application/\texorpdfstring{$\ast$}{*}+json}. The full mime type will be returned if matched.
\end{DoxyItemize}

Some examples to illustrate the inputs and returned value\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ mediaType\ =\ 'application/json'}
\DoxyCodeLine{}
\DoxyCodeLine{typeis.is(mediaType,\ ['json'])\ //\ =>\ 'json'}
\DoxyCodeLine{typeis.is(mediaType,\ ['html',\ 'json'])\ //\ =>\ 'json'}
\DoxyCodeLine{typeis.is(mediaType,\ ['application/*'])\ //\ =>\ 'application/json'}
\DoxyCodeLine{typeis.is(mediaType,\ ['application/json'])\ //\ =>\ 'application/json'}
\DoxyCodeLine{}
\DoxyCodeLine{typeis.is(mediaType,\ ['html'])\ //\ =>\ false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md4021}{}\doxysubsubsection{\texorpdfstring{typeis.\+match(expected, actual)}{typeis.\+match(expected, actual)}}\label{README.md_autotoc_md4021}
Match the type string {\ttfamily expected} with {\ttfamily actual}, taking in to account wildcards. A wildcard can only be in the type of the subtype part of a media type and only in the {\ttfamily expected} value (as {\ttfamily actual} should be the real media type to match). A suffix can still be included even with a wildcard subtype. If an input is malformed, {\ttfamily false} will be returned.


\begin{DoxyCode}{0}
\DoxyCodeLine{typeis.match('text/html',\ 'text/html')\ //\ =>\ true}
\DoxyCodeLine{typeis.match('*/html',\ 'text/html')\ //\ =>\ true}
\DoxyCodeLine{typeis.match('text/*',\ 'text/html')\ //\ =>\ true}
\DoxyCodeLine{typeis.match('*/*',\ 'text/html')\ //\ =>\ true}
\DoxyCodeLine{typeis.match('*/*+json',\ 'application/x-\/custom+json')\ //\ =>\ true}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md4022}{}\doxysubsubsection{\texorpdfstring{typeis.\+normalize(type)}{typeis.\+normalize(type)}}\label{README.md_autotoc_md4022}
Normalize a {\ttfamily type} string. This works by performing the following\+:


\begin{DoxyItemize}
\item If the {\ttfamily type} is not a string, {\ttfamily false} is returned.
\item If the string starts with {\ttfamily +} (so it is a {\ttfamily +suffix} shorthand like {\ttfamily +json}), then it is expanded to contain the complete wildcard notation of {\ttfamily \texorpdfstring{$\ast$}{*}/\texorpdfstring{$\ast$}{*}+suffix}.
\item If the string contains a {\ttfamily /}, then it is returned as the type.
\item Else the string is assumed to be a file extension and the mapped media type is returned, or {\ttfamily false} is there is no mapping.
\end{DoxyItemize}

This includes two special mappings\+:


\begin{DoxyItemize}
\item `\textquotesingle{}multipart'{\ttfamily -\/\texorpdfstring{$>$}{>}}\textquotesingle{}multipart/\texorpdfstring{$\ast$}{*}\textquotesingle{}{\ttfamily  -\/}\textquotesingle{}urlencoded\textquotesingle{}{\ttfamily -\/\texorpdfstring{$>$}{>}}\textquotesingle{}application/x-\/www-\/form-\/urlencoded\textquotesingle{}\`{}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md4023}{}\doxysubsection{\texorpdfstring{Examples}{Examples}}\label{README.md_autotoc_md4023}
\hypertarget{README.md_autotoc_md4024}{}\doxysubsubsection{\texorpdfstring{Example body parser}{Example body parser}}\label{README.md_autotoc_md4024}

\begin{DoxyCode}{0}
\DoxyCodeLine{var\ express\ =\ require('express')}
\DoxyCodeLine{var\ typeis\ =\ require('type-\/is')}
\DoxyCodeLine{}
\DoxyCodeLine{var\ app\ =\ express()}
\DoxyCodeLine{}
\DoxyCodeLine{app.use(function\ bodyParser\ (req,\ res,\ next)\ \{}
\DoxyCodeLine{\ \ if\ (!typeis.hasBody(req))\ \{}
\DoxyCodeLine{\ \ \ \ return\ next()}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ switch\ (typeis(req,\ ['urlencoded',\ 'json',\ 'multipart']))\ \{}
\DoxyCodeLine{\ \ \ \ case\ 'urlencoded':}
\DoxyCodeLine{\ \ \ \ \ \ //\ parse\ urlencoded\ body}
\DoxyCodeLine{\ \ \ \ \ \ throw\ new\ Error('implement\ urlencoded\ body\ parsing')}
\DoxyCodeLine{\ \ \ \ case\ 'json':}
\DoxyCodeLine{\ \ \ \ \ \ //\ parse\ json\ body}
\DoxyCodeLine{\ \ \ \ \ \ throw\ new\ Error('implement\ json\ body\ parsing')}
\DoxyCodeLine{\ \ \ \ case\ 'multipart':}
\DoxyCodeLine{\ \ \ \ \ \ //\ parse\ multipart\ body}
\DoxyCodeLine{\ \ \ \ \ \ throw\ new\ Error('implement\ multipart\ body\ parsing')}
\DoxyCodeLine{\ \ \ \ default:}
\DoxyCodeLine{\ \ \ \ \ \ //\ 415\ error\ code}
\DoxyCodeLine{\ \ \ \ \ \ res.statusCode\ =\ 415}
\DoxyCodeLine{\ \ \ \ \ \ res.end()}
\DoxyCodeLine{\ \ \ \ \ \ break}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md4025}{}\doxysubsection{\texorpdfstring{License}{License}}\label{README.md_autotoc_md4025}
\mbox{[}MIT\mbox{]}(LICENSE) 