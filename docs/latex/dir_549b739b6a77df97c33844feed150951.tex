\doxysection{node\+\_\+modules/sift Directory Reference}
\hypertarget{dir_549b739b6a77df97c33844feed150951}{}\label{dir_549b739b6a77df97c33844feed150951}\index{node\_modules/sift Directory Reference@{node\_modules/sift Directory Reference}}
\doxysubsubsection*{Directories}
\begin{DoxyCompactItemize}
\item 
directory \mbox{\hyperlink{dir_8292c03cbc9f3c3be29fab85edc0924d}{es}}
\item 
directory \mbox{\hyperlink{dir_e53d7bd7844cac0d0fc4b6999a421f43}{es5m}}
\item 
directory \mbox{\hyperlink{dir_862de5c11f616f7e2708da2b79812a6d}{lib}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+Installation\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+: \`{}npm install sift\`{}, or \`{}yarn add sift\`{}\hypertarget{README.md_autotoc_md3781}{}\doxysubsubsection{\texorpdfstring{Sift is a tiny library for using Mongo\+DB queries in Javascript}{Sift is a tiny library for using Mongo\+DB queries in Javascript}}\label{README.md_autotoc_md3781}
\href{https://secure.travis-ci.org/crcn/sift.js}{\texttt{ }}

{\bfseries{For extended documentation, checkout \href{http://docs.mongodb.org/manual/reference/operator/query/}{\texttt{ http\+://docs.\+mongodb.\+org/manual/reference/operator/query/}}}}\hypertarget{README.md_autotoc_md3782}{}\doxysubsubsection{\texorpdfstring{Features\+:}{Features\+:}}\label{README.md_autotoc_md3782}

\begin{DoxyItemize}
\item Supported operators\+: \$in, \$nin, \$exists, \$gte, \$gt, \$lte, \$lt, \$eq, \$ne, \$mod, \$all, \$and, \$or, \$nor, \$not, \$size, \$type, \$regex, \$where, \$elem\+Match
\item Regexp searches
\item Supports node.\+js, and web
\item Custom Operations
\item Tree-\/shaking (omitting functionality from web app bundles)
\end{DoxyItemize}\hypertarget{README.md_autotoc_md3783}{}\doxysubsubsection{\texorpdfstring{Examples}{Examples}}\label{README.md_autotoc_md3783}

\begin{DoxyCode}{0}
\DoxyCodeLine{import\ sift\ from\ "{}sift"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ intersecting\ arrays}
\DoxyCodeLine{const\ result1\ =\ ["{}hello"{},\ "{}sifted"{},\ "{}array!"{}].filter(}
\DoxyCodeLine{\ \ sift(\{\ \$in:\ ["{}hello"{},\ "{}world"{}]\ \}),}
\DoxyCodeLine{);\ //\ ['hello']}
\DoxyCodeLine{}
\DoxyCodeLine{//\ regexp\ filter}
\DoxyCodeLine{const\ result2\ =\ ["{}craig"{},\ "{}john"{},\ "{}jake"{}].filter(sift(/\string^j/));\ //['john','jake']}
\DoxyCodeLine{}
\DoxyCodeLine{//\ function\ filter}
\DoxyCodeLine{const\ testFilter\ =\ sift(\{}
\DoxyCodeLine{\ \ //you\ can\ also\ filter\ against\ functions}
\DoxyCodeLine{\ \ name:\ function\ (value)\ \{}
\DoxyCodeLine{\ \ \ \ return\ value.length\ ==\ 5;}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ result3\ =\ [}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ name:\ "{}craig"{},}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ name:\ "{}john"{},}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ name:\ "{}jake"{},}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{].filter(testFilter);\ //\ filtered:\ [\{\ name:\ 'craig'\ \}]}
\DoxyCodeLine{}
\DoxyCodeLine{//\ you\ can\ test\ *single\ values*\ against\ your\ custom\ sifter}
\DoxyCodeLine{testFilter(\{\ name:\ "{}sarah"{}\ \});\ //true}
\DoxyCodeLine{testFilter(\{\ name:\ "{}tim"{}\ \});\ //false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3784}{}\doxysubsubsection{\texorpdfstring{API}{API}}\label{README.md_autotoc_md3784}
\hypertarget{README.md_autotoc_md3785}{}\doxysubsubsubsection{\texorpdfstring{sift(query\+: Mongo\+Query, options?\+: Options)\+: Function}{sift(query\+: Mongo\+Query, options?\+: Options)\+: Function}}\label{README.md_autotoc_md3785}
Creates a filter with all the built-\/in Mongo\+DB query operations.


\begin{DoxyItemize}
\item {\ttfamily query} -\/ the filter to use against the target array
\item {\ttfamily options}
\begin{DoxyItemize}
\item {\ttfamily operations} -\/ custom operations
\item {\ttfamily compare} -\/ compares difference between two values
\end{DoxyItemize}
\end{DoxyItemize}

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ sift\ from\ "{}sift"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ test\ =\ sift(\{\ \$gt:\ 5\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(test(6));\ //\ true}
\DoxyCodeLine{console.log(test(4));\ //\ false}
\DoxyCodeLine{}
\DoxyCodeLine{[3,\ 4,\ 5,\ 6,\ 7].filter(test);\ //\ [6,\ 7]}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3786}{}\doxysubsubsubsection{\texorpdfstring{create\+Query\+Tester(query\+: Query, options?\+: Options)\+: Function}{create\+Query\+Tester(query\+: Query, options?\+: Options)\+: Function}}\label{README.md_autotoc_md3786}
Creates a filter function {\bfseries{without}} built-\/in Mongo\+DB query operations. This is useful if you\textquotesingle{}re looking to omit certain operations from application bundles. See Omitting built-\/in operations for more info.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ createQueryTester,\ \$eq,\ \$in\ \}\ from\ "{}sift"{};}
\DoxyCodeLine{const\ filter\ =\ createQueryTester(\{\ \$eq:\ 5\ \},\ \{\ operations:\ \{\ \$eq,\ \$in\ \}\ \});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3787}{}\doxysubsubsubsection{\texorpdfstring{create\+Equals\+Operation(params\+: any, owner\+Query\+: Query, options\+: Options)\+: Operation}{create\+Equals\+Operation(params\+: any, owner\+Query\+: Query, options\+: Options)\+: Operation}}\label{README.md_autotoc_md3787}
Used for custom operations.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ createQueryTester,\ createEqualsOperation,\ \$eq,\ \$in\ \}\ from\ "{}sift"{};}
\DoxyCodeLine{const\ filter\ =\ createQueryTester(}
\DoxyCodeLine{\ \ \{\ \$mod:\ 5\ \},}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ operations:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \$something(mod,\ ownerQuery,\ options)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ createEqualsOperation(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ (value)\ =>\ value\ \%\ mod\ ===\ 0,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ ownerQuery,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ options,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ );}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{);}
\DoxyCodeLine{filter(10);\ //\ true}
\DoxyCodeLine{filter(11);\ //\ false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3788}{}\doxysubsubsection{\texorpdfstring{Supported Operators}{Supported Operators}}\label{README.md_autotoc_md3788}
See Mongo\+DB\textquotesingle{}s \href{http://www.mongodb.org/display/DOCS/Advanced+Queries}{\texttt{ advanced queries}} for more info.\hypertarget{README.md_autotoc_md3789}{}\doxysubsubsubsection{\texorpdfstring{\$in}{\$in}}\label{README.md_autotoc_md3789}
array value must be \+\_\+\$in\+\_\+ the given query\+:

Intersecting two arrays\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ ['Brazil']}
\DoxyCodeLine{["{}Brazil"{},\ "{}Haiti"{},\ "{}Peru"{},\ "{}Chile"{}].filter(}
\DoxyCodeLine{\ \ sift(\{\ \$in:\ ["{}Costa\ Rica"{},\ "{}Brazil"{}]\ \}),}
\DoxyCodeLine{);}

\end{DoxyCode}


Here\textquotesingle{}s another example. This acts more like the \$or operator\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[\{\ name:\ "{}Craig"{},\ location:\ "{}Brazil"{}\ \}].filter(}
\DoxyCodeLine{\ \ sift(\{\ location:\ \{\ \$in:\ ["{}Costa\ Rica"{},\ "{}Brazil"{}]\ \}\ \}),}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3790}{}\doxysubsubsubsection{\texorpdfstring{\$nin}{\$nin}}\label{README.md_autotoc_md3790}
Opposite of \$in\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ ['Haiti','Peru','Chile']}
\DoxyCodeLine{["{}Brazil"{},\ "{}Haiti"{},\ "{}Peru"{},\ "{}Chile"{}].filter(}
\DoxyCodeLine{\ \ sift(\{\ \$nin:\ ["{}Costa\ Rica"{},\ "{}Brazil"{}]\ \}),}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3791}{}\doxysubsubsubsection{\texorpdfstring{\$exists}{\$exists}}\label{README.md_autotoc_md3791}
Checks if whether a value exists\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ ['Craig','Tim']}
\DoxyCodeLine{sift(\{\ \$exists:\ true\ \})(["{}Craig"{},\ null,\ "{}Tim"{}]);}

\end{DoxyCode}


You can also filter out values that don\textquotesingle{}t exist


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [\{\ name:\ "{}Tim"{}\ \}]}
\DoxyCodeLine{[\{\ name:\ "{}Craig"{},\ city:\ "{}Minneapolis"{}\ \},\ \{\ name:\ "{}Tim"{}\ \}].filter(}
\DoxyCodeLine{\ \ sift(\{\ city:\ \{\ \$exists:\ false\ \}\ \}),}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3792}{}\doxysubsubsubsection{\texorpdfstring{\$gte}{\$gte}}\label{README.md_autotoc_md3792}
Checks if a number is \texorpdfstring{$>$}{>}= value\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [2,\ 3]}
\DoxyCodeLine{[0,\ 1,\ 2,\ 3].filter(sift(\{\ \$gte:\ 2\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3793}{}\doxysubsubsubsection{\texorpdfstring{\$gt}{\$gt}}\label{README.md_autotoc_md3793}
Checks if a number is \texorpdfstring{$>$}{>} value\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [3]}
\DoxyCodeLine{[0,\ 1,\ 2,\ 3].filter(sift(\{\ \$gt:\ 2\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3794}{}\doxysubsubsubsection{\texorpdfstring{\$lte}{\$lte}}\label{README.md_autotoc_md3794}
Checks if a number is \texorpdfstring{$<$}{<}= value.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [0,\ 1,\ 2]}
\DoxyCodeLine{[0,\ 1,\ 2,\ 3].filter(sift(\{\ \$lte:\ 2\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3795}{}\doxysubsubsubsection{\texorpdfstring{\$lt}{\$lt}}\label{README.md_autotoc_md3795}
Checks if number is \texorpdfstring{$<$}{<} value.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [0,\ 1]}
\DoxyCodeLine{[0,\ 1,\ 2,\ 3].filter(sift(\{\ \$lt:\ 2\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3796}{}\doxysubsubsubsection{\texorpdfstring{\$eq}{\$eq}}\label{README.md_autotoc_md3796}
Checks if {\ttfamily query === value}. Note that \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\$eq can be omitted\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}. For \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\$eq\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}, and \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\$ne\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [\{\ state:\ 'MN'\ \}]}
\DoxyCodeLine{[\{\ state:\ "{}MN"{}\ \},\ \{\ state:\ "{}CA"{}\ \},\ \{\ state:\ "{}WI"{}\ \}].filter(}
\DoxyCodeLine{\ \ sift(\{\ state:\ \{\ \$eq:\ "{}MN"{}\ \}\ \}),}
\DoxyCodeLine{);}

\end{DoxyCode}


Or\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [\{\ state:\ 'MN'\ \}]}
\DoxyCodeLine{[\{\ state:\ "{}MN"{}\ \},\ \{\ state:\ "{}CA"{}\ \},\ \{\ state:\ "{}WI"{}\ \}].filter(}
\DoxyCodeLine{\ \ sift(\{\ state:\ "{}MN"{}\ \}),}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3797}{}\doxysubsubsubsection{\texorpdfstring{\$ne}{\$ne}}\label{README.md_autotoc_md3797}
Checks if {\ttfamily query !== value}.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [\{\ state:\ 'CA'\ \},\ \{\ state:\ 'WI'\}]}
\DoxyCodeLine{[\{\ state:\ "{}MN"{}\ \},\ \{\ state:\ "{}CA"{}\ \},\ \{\ state:\ "{}WI"{}\ \}].filter(}
\DoxyCodeLine{\ \ sift(\{\ state:\ \{\ \$ne:\ "{}MN"{}\ \}\ \}),}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3798}{}\doxysubsubsubsection{\texorpdfstring{\$mod}{\$mod}}\label{README.md_autotoc_md3798}
Modulus\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [300,\ 600]}
\DoxyCodeLine{[100,\ 200,\ 300,\ 400,\ 500,\ 600].filter(sift(\{\ \$mod:\ [3,\ 0]\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3799}{}\doxysubsubsubsection{\texorpdfstring{\$all}{\$all}}\label{README.md_autotoc_md3799}
values must match {\bfseries{everything}} in array\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [\ \{\ tags:\ ['books','programming','travel'\ ]\}\ ]}
\DoxyCodeLine{[}
\DoxyCodeLine{\ \ \{\ tags:\ ["{}books"{},\ "{}programming"{},\ "{}travel"{}]\ \},}
\DoxyCodeLine{\ \ \{\ tags:\ ["{}travel"{},\ "{}cooking"{}]\ \},}
\DoxyCodeLine{].filter(sift(\{\ tags:\ \{\ \$all:\ ["{}books"{},\ "{}programming"{}]\ \}\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3800}{}\doxysubsubsubsection{\texorpdfstring{\$and}{\$and}}\label{README.md_autotoc_md3800}
ability to use an array of expressions. All expressions must test true.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [\ \{\ name:\ 'Craig',\ state:\ 'MN'\ \}]}
\DoxyCodeLine{}
\DoxyCodeLine{[}
\DoxyCodeLine{\ \ \{\ name:\ "{}Craig"{},\ state:\ "{}MN"{}\ \},}
\DoxyCodeLine{\ \ \{\ name:\ "{}Tim"{},\ state:\ "{}MN"{}\ \},}
\DoxyCodeLine{\ \ \{\ name:\ "{}Joe"{},\ state:\ "{}CA"{}\ \},}
\DoxyCodeLine{].filter(sift(\{\ \$and:\ [\{\ name:\ "{}Craig"{}\ \},\ \{\ state:\ "{}MN"{}\ \}]\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3801}{}\doxysubsubsubsection{\texorpdfstring{\$or}{\$or}}\label{README.md_autotoc_md3801}
OR array of expressions.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [\ \{\ name:\ 'Craig',\ state:\ 'MN'\ \},\ \{\ name:\ 'Tim',\ state:\ 'MN'\ \}]}
\DoxyCodeLine{[}
\DoxyCodeLine{\ \ \{\ name:\ "{}Craig"{},\ state:\ "{}MN"{}\ \},}
\DoxyCodeLine{\ \ \{\ name:\ "{}Tim"{},\ state:\ "{}MN"{}\ \},}
\DoxyCodeLine{\ \ \{\ name:\ "{}Joe"{},\ state:\ "{}CA"{}\ \},}
\DoxyCodeLine{].filter(sift(\{\ \$or:\ [\{\ name:\ "{}Craig"{}\ \},\ \{\ state:\ "{}MN"{}\ \}]\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3802}{}\doxysubsubsubsection{\texorpdfstring{\$nor}{\$nor}}\label{README.md_autotoc_md3802}
opposite of or\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ [\{\ name:\ 'Joe',\ state:\ 'CA'\ \}]}
\DoxyCodeLine{[}
\DoxyCodeLine{\ \ \{\ name:\ "{}Craig"{},\ state:\ "{}MN"{}\ \},}
\DoxyCodeLine{\ \ \{\ name:\ "{}Tim"{},\ state:\ "{}MN"{}\ \},}
\DoxyCodeLine{\ \ \{\ name:\ "{}Joe"{},\ state:\ "{}CA"{}\ \},}
\DoxyCodeLine{].filter(sift(\{\ \$nor:\ [\{\ name:\ "{}Craig"{}\ \},\ \{\ state:\ "{}MN"{}\ \}]\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3803}{}\doxysubsubsubsection{\texorpdfstring{\$size}{\$size}}\label{README.md_autotoc_md3803}
Matches an array -\/ must match given size\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ filtered:\ ['food','cooking']}
\DoxyCodeLine{[\{\ tags:\ ["{}food"{},\ "{}cooking"{}]\ \},\ \{\ tags:\ ["{}traveling"{}]\ \}].filter(}
\DoxyCodeLine{\ \ sift(\{\ tags:\ \{\ \$size:\ 2\ \}\ \}),}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3804}{}\doxysubsubsubsection{\texorpdfstring{\$type}{\$type}}\label{README.md_autotoc_md3804}
Matches a values based on the type


\begin{DoxyCode}{0}
\DoxyCodeLine{[new\ Date(),\ 4342,\ "{}hello\ world"{}].filter(sift(\{\ \$type:\ Date\ \}));\ //\ returns\ single\ date}
\DoxyCodeLine{[new\ Date(),\ 4342,\ "{}hello\ world"{}].filter(sift(\{\ \$type:\ String\ \}));\ //\ returns\ ['hello\ world']}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3805}{}\doxysubsubsubsection{\texorpdfstring{\$regex}{\$regex}}\label{README.md_autotoc_md3805}
Matches values based on the given regular expression


\begin{DoxyCode}{0}
\DoxyCodeLine{["{}frank"{},\ "{}fred"{},\ "{}sam"{},\ "{}frost"{}].filter(}
\DoxyCodeLine{\ \ sift(\{\ \$regex:\ /\string^f/i,\ \$nin:\ ["{}frank"{}]\ \}),}
\DoxyCodeLine{);\ //\ ["{}fred"{},\ "{}frost"{}]}
\DoxyCodeLine{["{}frank"{},\ "{}fred"{},\ "{}sam"{},\ "{}frost"{}].filter(}
\DoxyCodeLine{\ \ sift(\{\ \$regex:\ "{}\string^f"{},\ \$options:\ "{}i"{},\ \$nin:\ ["{}frank"{}]\ \}),}
\DoxyCodeLine{);\ //\ ["{}fred"{},\ "{}frost"{}]}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3806}{}\doxysubsubsubsection{\texorpdfstring{\$where}{\$where}}\label{README.md_autotoc_md3806}
Matches based on some javascript comparison


\begin{DoxyCode}{0}
\DoxyCodeLine{[\{\ name:\ "{}frank"{}\ \},\ \{\ name:\ "{}joe"{}\ \}].filter(}
\DoxyCodeLine{\ \ sift(\{\ \$where:\ "{}this.name\ ===\ 'frank'"{}\ \}),}
\DoxyCodeLine{);\ //\ ["{}frank"{}]}
\DoxyCodeLine{[\{\ name:\ "{}frank"{}\ \},\ \{\ name:\ "{}joe"{}\ \}].filter(}
\DoxyCodeLine{\ \ sift(\{}
\DoxyCodeLine{\ \ \ \ \$where:\ function\ ()\ \{}
\DoxyCodeLine{\ \ \ \ \ \ return\ this.name\ ===\ "{}frank"{};}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \}),}
\DoxyCodeLine{);\ //\ ["{}frank"{}]}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3807}{}\doxysubsubsubsection{\texorpdfstring{\$elem\+Match}{\$elem\+Match}}\label{README.md_autotoc_md3807}
Matches elements of array


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ bills\ =\ [}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ month:\ "{}july"{},}
\DoxyCodeLine{\ \ \ \ casts:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 200,}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ 2,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 1000,}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ ],}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ month:\ "{}august"{},}
\DoxyCodeLine{\ \ \ \ casts:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ 3,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 1000,}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ 4,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 4000,}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ ],}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{];}
\DoxyCodeLine{}
\DoxyCodeLine{var\ result\ =\ bills.filter(}
\DoxyCodeLine{\ \ sift(\{}
\DoxyCodeLine{\ \ \ \ casts:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \$elemMatch:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ \{\ \$gt:\ 1000\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \}),}
\DoxyCodeLine{);\ //\ \{month:'august',\ casts:[\{id:3,\ value:\ 1000\},\{id:\ 4,\ value:\ 4000\}]\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3808}{}\doxysubsubsubsection{\texorpdfstring{\$not}{\$not}}\label{README.md_autotoc_md3808}
Not expression\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{["{}craig"{},\ "{}tim"{},\ "{}jake"{}].filter(sift(\{\ \$not:\ \{\ \$in:\ ["{}craig"{},\ "{}tim"{}]\ \}\ \}));\ //\ ['jake']}
\DoxyCodeLine{["{}craig"{},\ "{}tim"{},\ "{}jake"{}].filter(sift(\{\ \$not:\ \{\ \$size:\ 5\ \}\ \}));\ //\ ['tim','jake']}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3809}{}\doxysubsubsubsection{\texorpdfstring{Date comparison}{Date comparison}}\label{README.md_autotoc_md3809}
Mongodb allows you to do date comparisons like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{db.collection.find(\{\ createdAt:\ \{\ \$gte:\ "{}2018-\/03-\/22T06:00:00Z"{}\ \}\ \});}

\end{DoxyCode}


In Sift, you\textquotesingle{}ll need to specify a Date object\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{collection.find(}
\DoxyCodeLine{\ \ sift(\{\ createdAt:\ \{\ \$gte:\ new\ Date("{}2018-\/03-\/22T06:00:00Z"{})\ \}\ \}),}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3810}{}\doxysubsubsection{\texorpdfstring{Custom behavior}{Custom behavior}}\label{README.md_autotoc_md3810}
Sift works like Mongo\+DB out of the box, but you\textquotesingle{}re also able to modify the behavior to suite your needs.\hypertarget{README.md_autotoc_md3811}{}\doxysubsubsubsubsection{\texorpdfstring{Custom operations}{Custom operations}}\label{README.md_autotoc_md3811}
You can register your own custom operations. Here\textquotesingle{}s an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ sift,\ \{\ createEqualsOperation\ \}\ from\ "{}sift"{};}
\DoxyCodeLine{}
\DoxyCodeLine{var\ filter\ =\ sift(}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ \$customMod:\ 2,}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ operations:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \$customMod(params,\ ownerQuery,\ options)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ createEqualsOperation(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ (value)\ =>\ value\ \%\ params\ !==\ 0,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ ownerQuery,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ options,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ );}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{[1,\ 2,\ 3,\ 4,\ 5].filter(filter);\ //\ [1,\ 3,\ 5]}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3812}{}\doxysubsubsubsubsection{\texorpdfstring{Omitting built-\/in operations}{Omitting built-\/in operations}}\label{README.md_autotoc_md3812}
You can create a filter function that omits the built-\/in operations like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ createQueryTester,\ \$in,\ \$all,\ \$nin,\ \$lt\ \}\ from\ "{}sift"{};}
\DoxyCodeLine{const\ test\ =\ createQueryTester(}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ \$eq:\ 10,}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ \{\ operations:\ \{\ \$in,\ \$all,\ \$nin,\ \$lt\ \}\ \},}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{[1,\ 2,\ 3,\ 4,\ 10].filter(test);}

\end{DoxyCode}


For bundlers like {\ttfamily Webpack} and {\ttfamily Rollup}, operations that aren\textquotesingle{}t used are omitted from application bundles via tree-\/shaking. 